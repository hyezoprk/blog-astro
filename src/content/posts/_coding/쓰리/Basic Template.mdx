---
title: '[Three-2D] Basic Template'
date: "2023-09-01"
categories: "coding"
tags: "ì“°ë¦¬ì œì´ì—ìŠ¤"
description: "Intro"
---

<HeadingNavigator />

ì´ë²ˆ í¸ì˜ ì£¼ì œëŠ” ë² ì´ì§ í…œí”Œë¦¿ì´ë‹¤. ë§ ê·¸ëŒ€ë¡œ ë² ì´ì§, `Three`ì˜ ê¸°ë³¸ ì¸ìŠ¤í„´ìŠ¤ë“¤ì„ í™œìš©í•˜ì—¬ í…œí”Œë¦¿ì„ ë§Œë“œëŠ” ê²Œ ëª©í‘œë‹¤.
<br/>
ë¬´ì‘ì • ì‹œì‘í•˜ê¸°ì— ì•ì„œ ì•Œì•„ì•¼ ê²ƒë“¤ì´ ìˆë‹¤. íŠ¹íˆ `shader`ì— ê´€í•œ ë‚´ìš©ì´ ê·¸ëŸ°ë°[^1], ë‚˜ëŠ” ë©‹ëª¨ë¥´ê³  ë¶€ë‹¥ì³¤ì§€ë§Œ ì•ˆ ê·¸ëŸ¬ë©´ í›¨ì”¬ ì¢‹ì•˜ì„ ê±°ë‹¤. ì •í™•í•˜ì§„ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ ê³µë¶€í•˜ê³  ì´í•´í•œ ë°”ë¥¼ ì¼ë‹¨ ì„œìˆ í•´ë³¸ë‹¤.
<br/>
---
<br/>
1. Threeì˜ ê¸°ë³¸ êµ¬ì„±ìš”ì†Œ
- Scene: ì˜¤ë¸Œì œë“¤ì„ ë‹´ëŠ” ì»¨í…Œì´ë„ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì˜ë¯¸í•˜ë“¯ í•˜ë‚˜ì˜ ì¥ë©´, í•˜ë‚˜ì˜ ì”¬ì„ ì˜ë¯¸í•œë‹¤.
- Object: í™”ë©´ì— ë‹´ê¸¸ í”¼ì‚¬ì²´ë‹¤. í”¼ì‚¬ì²´ëŠ” í˜•íƒœì™€ ì„±ì§ˆë¡œ ê²°í•©ë˜ëŠ”ë°, í˜•íƒœëŠ” `geometry`ë¡œ, ì„±ì§ˆì€ `material`ë¡œ ì •ì˜í•œë‹¤. `Mesh`ëŠ” ì´ ë‘˜ì„ ê²°í•©ì´ë‹¤.
- Camera: ì‚¬ìš©ìì˜ ì‹œì ì´ë‹¤. ì˜¤ë¸Œì œë¥¼ ë°”ë¼ë³¼ ê°ë„, ì˜¤ë¸Œì œë¥¼ ë‹´ì„ ë²”ìœ„ ë“±ì„ ì •ì˜í•œë‹¤. ê¼­ í•œê°œê°€ ì•„ë‹ˆë¼ ì—¬ëŸ¬ ê°œê°€ ì“°ì¼ ìˆ˜ ìˆë‹¤.
- WebGLRenderer: Sceneê³¼ Cameraë¥¼ ê²°í•©í•´ ì‹¤ì œë¡œ ë Œë”ë§í•œë‹¤. ë¬´ëŒ€ì™€ ì¹´ë©”ë¼ê°€ ì¤€ë¹„ëìœ¼ë‹ˆ ì´¬ì˜ì— ë“¤ì–´ê°€ëŠ” ë‹¨ê³„ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤. ë²„íŠ¼ì€ `render` ë©”ì¨ë“œë‹¤. í˜¸ì¶œí•˜ë©´ í•œ ì¥ì˜ ì‚¬ì§„ì´ ì°íˆëŠ”ë°, ë™ì˜ìƒ(ì• ë‹ˆë©”ì´ì…˜)ì„ ìœ„í•´ì„œëŠ” `requestAnimationFrame`ìœ¼ë¡œ ë°˜ë³µí•´ì„œ í˜¸ì¶œí•œë‹¤.
<br/>

2. Shader
- Shader: ì‰½ê²Œ ë§í•´ ê·¸ë˜í”½ì„ ê·¸ë¦¬ëŠ” ë°©ë²•ì´ë‹¤. íŒŒì¼ í™•ì¥ìëŠ” `glsl`ì´ë‹¤. `vertexShader`ì™€ `fragmentShader`ë¡œ êµ¬ì„±ëœë‹¤.
- vertexShader: 3ì°¨ì› ì¢Œí‘œë¡œ ì´ë£¨ì–´ì§„ vertexë“¤ì´ 2ì°¨ì› í™”ë©´ì—ì„œ ê·¸ë ¤ì§ˆ ìœ„ì¹˜ë¥¼ ì •ì˜í•œë‹¤. ì¦‰ ê¼­ì§€ì ì˜ êµ¬ì„±, ìë¦¬ì¡ìŒì„ ë‹´ë‹¹í•œë‹¤. ë¸Œë¼ìš°ì € í™”ë©´ì´ 2Dì´ê¸° ë•Œë¬¸ì— í•„ìš”í•œ ì‹œê°ì  ì¹˜í™˜ ê³¼ì •ì´ë‹¤. ì•„ë˜ ê·¸ë¦¼ì˜ ë‘ë²ˆì§¸ë¥¼ ì°¸ê³ . <Img src='/images/2023/three/shader.jpeg' />
> ğŸ‘€ <b>vertexShaderì— ì£¼ì–´ì§€ëŠ” ê¸°ë³¸ ë³€ìˆ˜</b>: <u>projectionMatrix</u> & <u>modelViewMatrix</u>
>
> vertexShaderì—ì„œëŠ” ê¼­ì§€ì ë“¤ì˜ ìœ„ì¹˜ë¥¼ ì •ì˜í•´ì¤˜ì•¼ í•œë‹¤. ì´ ì„¤ì •ì„ ìœ„í•´ ì£¼ì–´ì§€ëŠ” ë³€ìˆ˜ê°€ ìˆë‹¤!
> - projectionMatrix: ì˜¤ë¸Œì œì˜ í¬ì§€ì…˜, í¬ê¸°, ì›€ì§ì„ì„ 2ì°¨ì› ë·°í¬íŠ¸ì— íˆ¬ì˜í•˜ëŠ” ë³€ìˆ˜
> - modelMatrix: ëª¨ë¸(ì˜¤ë¸Œì œ)ì˜ ì´ë™, íšŒì „, í¬ê¸° ë“± ë³€í˜•ê°’ì„ ê³„ì‚°í•˜ëŠ” ë³€ìˆ˜
> - viewMatrix: ì¹´ë©”ë¼ì˜ ë°°ì¹˜ë¥¼ ì¡°ì •í•˜ì—¬ í™”ë©´ì˜ ì‹œì ì„ ê³„ì‚°í•˜ëŠ” ë³€ìˆ˜
> ---
> - ë‘˜ë‹¤ ê¸°ë³¸ì ìœ¼ë¡œ ê³„ì‚°ë¼ì„œ ì£¼ì–´ì§€ì§€ë§Œ, RawMaterialShaderë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ì´ ë‘˜ì„ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í•œ ë’¤ ì§ì ‘ ê³„ì‚°í•´ì•¼ í•œë‹¤.
> - ìˆœì„œë¥¼ ë°”ê¿”ì„œë„ ì•ˆ ëœë‹¤. ë°˜ë“œì‹œ projectionMatrixê°€ ì œì¼ ì•ìœ¼ë¡œ ì™€ì•¼ í•œë‹¤.
> - ì…°ì´ë”ì˜ ê³±ì…ˆ ìˆœì„œëŠ” ì¼ë°˜ì ìœ¼ë¡œ projectionMatrix * modelViewMatrix * position ì´ë‹¤. ì´ ê°’ì„ ì •í•´ì§„ ë³€ìˆ˜ <u>gl_position</u>ì— í• ë‹¹í•˜ë©´(ì´ ë§¤íŠ¸ë¦­ìŠ¤ëŠ” -1ë¶€í„° 1ì˜ ì¢Œí‘œ ë²”ìœ„ë¥¼ ê°–ëŠ”ë‹¤) ê¼­ì§€ì ë“¤ì´ í™”ë©´ì— ë‚˜íƒ€ë‚  ìœ„ì¹˜ê°€ ê²°ì •ëœë‹¤.
> - ë§ˆì°¬ê°€ì§€ë¡œ <u>gl_PointSize</u>ëŠ” ê¼­ì§€ì ë“¤ì˜ í¬ê¸°ë¥¼ ì •ì˜í•œë‹¤.
> - ê°€ë ¹ ê³±ì…ˆ íŒŒì´í”„ë¼ì¸ì—ì„œ viewMatrixë¥¼ ë¹¼ë©´ ì¹´ë©”ë¼ ì‹œì ì„ ì¡°ì •í•˜ì§€ ëª»í•œë‹¤.
> <Img src='/images/2023/three/vertexShader1.png' />

- `fragmentShader`: vertex ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë§Œë“¤ì–´ì§€ëŠ” ë‹¨ë©´ì ì— ê´€ì—¬í•˜ëŠ” ì…°ì´ë”ë‹¤. ë‹¨ë©´ì ì„ ì°¨ì§€í•˜ëŠ” í”½ì…€ í•˜ë‚˜í•˜ë‚˜ì˜ ìƒ‰ìƒ, ê·¸ë¦¼ì, ì¤‘ë ¥ ë° ë¶„ì‚° ë“± ì—°ì‚°ì„ í†µí•´ ì—¬ëŸ¬ ê°€ì§€ ì´í™íŠ¸ë¥¼ ë§Œë“¤ì–´ë‚¸ë‹¤. ìœ— ê·¸ë¦¼ì˜ ë„¤ë²ˆì§¸ë¥¼ ë³´ì.
- ê·¸ ë°–ì—..
> <b>glsl ë³€ìˆ˜íƒ€ì…</b>
> - attribute: geometryì— ì†í•˜ëŠ” ì–´íŠ¸ë¦¬ë·°íŠ¸. geometry.setAttribute(name, value)ë¡œ ì„¤ì •í•œë‹¤. ì£¼ì˜í•  ì ì€ vertexShaderì—ì„œë§Œ ì“¸ ìˆ˜ ìˆê³ , fragmentShaderì—ì„œëŠ” attribute ë³€ìˆ˜ì— ëŒ€í•œ ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.
> - uniform: materialì— ì†í•˜ëŠ” í”„ë¡œí¼í‹°. material.uniforms.name.value = valueë¡œ ì„¤ì •í•œë‹¤. vertexShaderì™€ fragmentShaderì—ì„œ ëª¨ë‘ ì“¸ ìˆ˜ ìˆë‹¤.
> - varrying: vertexShaderì—ì„œ fragmentShaderë¡œ ê°’ì„ ì „ë‹¬í•  ë•Œ ì‚¬ìš©í•œë‹¤. vertexShaderì—ì„œ ì„ ì–¸ê³¼ í• ë‹¹ì„ ë§ˆì¹˜ë©´ fragmentShaderì—ì„œë„ ì´ ê°’ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
> ---
> <b>geometryì˜ ë””í´íŠ¸ attribute</b>
> - vec3 position: 3ì°¨ì›ì—ì„œ ê¼­ì§€ì ì˜ ìœ„ì¹˜.  
> - vec3 normal: 3ì°¨ì›ì—ì„œ ê° ê¼­ì§€ì ì´ ê°€ì§„ ë°©í–¥ì„±(ë¨¸ë¦¬ì™€ ê¼¬ë¦¬)  
> - vec2 uv: 2D í…ìŠ¤ì³ë¥¼ 3D ëª¨ë¸ì— ì…íˆê¸° ìœ„í•´ ê³„ì‚°ë˜ëŠ” ê°’. 0 ~ 1 ì‚¬ì´ì˜ ê°’ì´ë‹¤.  

#### ì¤‘ê°„ì •ë¦¬
- <u>vertex</u> -> GPU : ìš°ë¦¬ ì—¬ê¸°ì— ìˆì–´! ìœ„ì¹˜ ì•Œë¦¬ë¯¸
- <u>fragment</u> -> GPU : ìš°ë¦¬ ì´ë ‡ê²Œ ì±„ì›Œì¤˜! ìƒ‰ì¹  ì•Œë¦¬ë¯¸
- geometry <u>attribute</u> -> í”„ë ˆì„ì›Œí¬ì— ì˜í•´ vertex shaderì—ë§Œ ì „ë‹¬/ì œê³µ
- material <u>uniform</u> -> vertex shader, fragment shader ëª¨ë‘ì—ê²Œ ì „ë‹¬/ì œê³µ
- <u>varrying</u> -> vertex shaderì—ì„œ ì„ ì–¸, í• ë‹¹ë˜ì–´ fragment shaderë¡œ ê³µìœ 
- ê·¸ë¦¬ê³  ë¬¸ê³¼ì ì¸ tip
> <b>ì •ê·œí™”ëŠ” ì–¸ì œ ì“°ëŠ”ê°€?</b>
> - ì •ê·œí™”ëŠ” ë²¡í„°ì˜ ê¸¸ì´ë¥¼ 1ë¡œ ë§Œë“ ë‹¤. ê¸¸ì´ê°€ 1ì´ë©´ ë²¡í„°ê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒì€ ë°©í–¥ì´ë‹¤.
> - ê·¸ëŸ´ ë•Œ `dot`ì˜ ì—­í• ì€? ë°©í–¥ì„ ë‚˜íƒ€ë‚´ëŠ” ë‘ ì¸ìˆ˜(ì¹´ë©”ë¼ì™€ í”¼ì‚¬ì²´)ë¥¼ í¬ê°œì–´ ì¼ì¹˜í•˜ë©´ 1, 90ë„ë¼ë©´ 0ì„ ë¦¬í„´í•œë‹¤.

> <b>ê·¸ ì™¸ í•¨ìˆ˜ë“¤ë¡œ ë…¸ë¦¬ëŠ” íš¨ê³¼</b>
> - abs: ëŒ€ì¹­ íš¨ê³¼
> - step: ëŒ€ë¹„ íš¨ê³¼(0 ì•„ë‹ˆë©´ 1ì¸ ìŠ¤ìœ„ì¹˜)
> - mix / clamp / smoothstep: ê·¸ë¼ë””ì–¸íŠ¸ íš¨ê³¼(ì„ í˜•ë³´ê°„)
> - normalize: ë°©í–¥ ê³„ì‚°
> - fract: ì»¬ëŸ¬ ê³„ì‚° (0~1ì˜ ì†Œìˆ˜ê°’)
> - dot: ê·¸ë¦¼ì(ë¹›) ê³„ì‚°


<br/>
--- 

### ì„¤ì¹˜

```bash
pnpm i -D three
```

```js sketch.js
import * as THREE from 'three';
import { OribitControls } from 'three/examples/jsm/controls/OrbitControls.js'; // ë§ˆìš°ìŠ¤ ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤
import vertexShader from './shaders/vertex.glsl';
import fragmentShader from './shaders/fragment.glsl';
```

### í´ë˜ìŠ¤ ì‘ì„±
ì„¤ì¹˜ê°€ ëë‹¤ë©´ í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•œë‹¤. ì•ì¥ì— ë”í•´ ë‹¤ìŒì˜ ë©”ì¨ë“œê°€ ì¶”ê°€ëë‹¤.
- `addObject`: ì˜¤ë¸Œì œ ì…‹íŒ…ì„ ì²˜ë¦¬
- `resizeSetup`: ì´ë²¤íŠ¸ë¦¬ìŠ¤ë„ˆ ì…‹íŒ…ì„ ì²˜ë¦¬
<br/>
ì „ì²´ ì½”ë“œë¥¼ í›‘ì–´ë³´ê³  ì„¸ë¶€ì ì¸ ë‚´ìš©ì„ ì‚´í´ë³´ì.

```js sketch.js
export default class Sketch {
  constructor(options) {
    this.container = options.dom;
    this.scene = new THREE.Scene();

    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;

    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setClearColor(0x222222, 1);
    this.renderer.setSize(this.width, this.height);
    this.container.appendChild(this.renderer.domElement); // <canvas />
	
    this.camera = new THREE.PerspectiveCamera(70, this.width / this.height, 0.01, 10);  // ë Œì¦ˆê°, ë·°íŒŒì¸ë” ë¹„ìœ¨, ìµœì†Œ zê°’, ìµœëŒ€ zê°’ 
    this.camera.position.z = 1;
    
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    
    this.resizeHandler = this.resize.bind(this);

    this.time = 0; 
		
    this.addObjects();
    this.resizeSetup();
    this.render();
  }  // ì»¨ìŠ¤íŠ¸ëŸ­í„°
  

  addObjects(){
    this.geometry = new THREE.PlaneGeometry(1, 1, 10, 10);
    this.position = // ë‹¤ìŒ ì‹œê°„ì— ì •ì˜í•œë‹¤.
    this.uv = // ë‹¤ìŒ ì‹œê°„ì— ì •ì˜í•œë‹¤.
    
    this.material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTime: { value: 0 };
        uTexture: { value: this.positions }, 
      },
      wireFrame: true,
    })q

    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.scene.add(this.mesh);
  }
  
  render(){
    this.time += 0.05;
    this.material.uniforms.time.value = this.time;
    
    this.mesh.rotation.x = this.time / 20;
    this.mesh.rotation.y = this.time / 10;
    
    this.renderer.render(this.scene, this.camera);
    
    this.rafId = requestAnimationFrame(this.render.bind(this))
  }

  resize() {
    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;

    this.renderer.setSize(this.width, this.height);
    this.camera.aspect = this.width / this.height;

    this.camera.updateProjectionMatrix();
	}
  
  // ì…‹ì—…
  resizeSetup(){
    addEventListener('resize', this.resizeHandler);
  }

  clearSetup(){
    removeEventListener('resize', this.resizeHandler);
    cancelAnimationFrame(this.rafId);
  }
}
```

### addObjects
`addObjects`ëŠ” ì˜¤ë¸Œì œ ë“±ë¡ì„ ë‹´ë‹¹í•œë‹¤. ì˜¤ë¸Œì œ(í”¼ì‚¬ì²´)ëŠ” í˜•íƒœì™€ ì„±ì§ˆì˜ ê²°í•©ì´ë‹¤. `geometry`ì™€ `material`ë¥¼ ë§Œë“¤ê³  `Mesh`ë¡œ ê²°í•©í•˜ì—¬ ì™„ì„±í•œë‹¤.
- planeGeometry: ì‚¬ê°í˜• í‰ë©´ ë„í˜•ì´ë‹¤. ë„¤ ê°œì˜ íŒŒë¼ë¯¸í„°ëŠ” ê°ê° `width`, `height`, `widthSegments`, `heightSegments`ë¥¼ ì˜ë¯¸í•œë‹¤. ì•ì˜ ë‘ ì¸ìë¡œ ì „ì²´ì ì¸ í¬ê¸°ë¥¼ ì¡°ì •í•˜ê³ , ë’¤ì˜ ë‘ ì¸ìë¡œ ê·¸ ì•ˆì„ ì±„ìš°ëŠ” ì‘ì€ fragmentë“¤ì˜ ì‚¬ì´ì¦ˆë¥¼ ì •ì˜í•œë‹¤(<Lnk text='ë§í¬' href='https://threejs.org/docs/#api/en/geometries/PlaneGeometry' />).
- ShaderMaterial: ì…°ì´ë”ë¥¼ ì‚¬ìš©í•˜ëŠ” materialì´ë‹¤. `wireFrame`ì„ `true`ë¡œ ì„¤ì •í•˜ë©´ ë„í˜•ì„ ë¼ˆëŒ€(scaffold)ë¡œ í‘œì‹œí•˜ê²Œ ë§Œë“ ë‹¤. ê°œë…ì—ì„œ ì‚´í´ë³¸ `vertexShader`, `fragmentShader`, `uniform` ë“±ì„ ì—¬ê¸°ì„œ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤(<Lnk text='ë§í¬' href='https://threejs.org/docs/#api/en/materials/ShaderMaterial' />).  
- vertexShader
```glsl vertex.glsl
varying vec2 vUv;
uniform float uTime;
uniform sampler2D uTexture;

void main() {
  vUv = uv;   // ê¸°ë³¸ ì†ì„± uvëŠ” read-only
  vec3 newpos = position; // ê¸°ë³¸ ì†ì„± positonì€ read-only
  newpos.x += 0.5;

  vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.0);

  gl_PointSize = (10.0 / -mvPosition.z);
  gl_Position = projectionMatrix * mvPosition;
}
```
> - newposì˜ xì¶•ì„ ëŠ˜ë¦¬ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ì§€ë§Œ, ë‹¤ìŒ ë Œë”ì‹œì—ëŠ” ì´ˆê¸°í™”ëœë‹¤.
> - glslì˜ ë§¤ì‹¤í–‰ì€ ë…ë¦½ì ì´ë‹¤. ì´ì „ ì‹¤í–‰ê°’ì„ ìºì‹±í•˜ì§€ ëª»í•œë‹¤. ì´ì „ ì‹¤í–‰ê°’ì„ ì €ì¥í•˜ê³  ì‹¶ìœ¼ë©´ js ìª½ì—ì„œ ê°’ì„ ì—…ë°ì´íŠ¸í•œ ë’¤, uniform ë³€ìˆ˜ë¡œ ë„˜ê¸´ë‹¤.  
> ë‹¤ìŒ ì‹œê°„ì— position ë°ì´í„°ë¥¼ ë§Œë“¤ê³  ì—…ë°ì´íŠ¸ í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë³¼ ê²ƒì´ë‹¤.

- fragmentShader
```glsl fragment.glsl
varying vec2 vUv;
uniform sampler2D uTexture;

void main() {
  vec4 color = texture2D(uTexture, vUv);
  gl_FragColor = color;
}
```

### setup
- `resizeSetup`: ë¸Œë¼ìš°ì €ì˜ ì‚¬ì´ì¦ˆë¥¼ ì¡°ì •í•  ë•Œë§ˆë‹¤ `resize` ë©”ì¨ë“œê°€ ì‹¤í–‰ë˜ê²Œ í•œë‹¤. ì»¨í…Œì´ë„ˆì˜ `width`, `height`ê°€ ê°±ì‹ ë˜ë©´ì„œ `renderer` ì‚¬ì´ì¦ˆ, `camera`ì˜ ë¹„ìœ¨ë„ ì¬ê³„ì‚°ëœë‹¤.
<br/>
---
<br/>
#### ì°¸ê³ í•œ ë¬¸ì„œ
[^1]: <Lnk text='The Book of Shader' href='https://thebookofshaders.com/01/?lan=kr' />